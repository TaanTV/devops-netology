# Домашнее задание к занятию "11.02 Микросервисы: принципы"

Вы работаете в крупной компанию, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps специалисту необходимо выдвинуть предложение по организации инфраструктуры, для разработки и эксплуатации.

### Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- Маршрутизация запросов к нужному сервису на основе конфигурации
- Возможность проверки аутентификационной информации в запросах
- Обеспечение терминации HTTPS

Обоснуйте свой выбор.

Ответ:

### Лучшим считается Nginx

| Сервис | Особенности      |
| ------------- | ------------- |
| Nginx | Легко внедряется, быстро работает, хорошая офф. документация, есть авторизация, поддерживает HTTPS и маршрутизацию |
| Apache httpd | Легко внедряется, хорошая офф. документация, есть авторизация, поддерживает HTTPS и маршрутизацию, пишут что  работает медленнее чем nginx |

Apache, и Nginx — это мощные, гибкие и функциональные инструменты. Для того чтобы выбрать сервер под ваши задачи необходимо определиться с требованиями к нему и провести тесты на всех возможных паттернах использования вашего приложения.

Выбор является серией компромиссов и не стоит пренебрегать тестами.

Если бы выбор пал что изучать первым, я бы выбрал Nginx

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- Поддержка кластеризации для обеспечения надежности
- Хранение сообщений на диске в процессе доставки
- Высокая скорость работы
- Поддержка различных форматов сообщений
- Разделение прав доступа к различным потокам сообщений
- Протота эксплуатации

Обоснуйте свой выбор.

Ответ: 



|№  | RabbitMQ       | Apache Kafka       |
| ------------- | ------------- | ------------- | 
| Сохранение сообщений  |   RabbitMQ помещает сообщение в очередь FIFO (First Input – First Output) и отслеживает статус этого сообщения в очереди, а Kafka добавляет сообщение в журнал (записывает на диск), предоставляя получателю самому заботиться о получении нужной информации из топика. Кролик удаляет сообщение после доставки его получателю|Кафка хранит сообщение до тех пор, пока не наступит момент запланированной очистки журнала. Таким образом, Apache Kafka сохраняет текущее и все прежние состояния системы и может использоваться в качестве достоверного источника исторических данных | 
| Балансировка| благодаря pull-модели доставки сообщений RabbitMQ сокращает время задержки, однако возможно переполнение получателей, если сообщения прибудут в очередь быстрее, чем те могут их обработать. Поскольку в RabbitMQ каждый получатель запрашивает/выгружает разное количество сообщений, то распределение работы может стать неравномерным, что повлечет задержки и потерю порядка сообщений во время обработки. Для предупреждения этого каждый получатель Кролика настраивает предел предварительной выборки (QoS) – ограничение на количество скопившихся неподтвержденных сообщений. | Apache Kafka балансировка нагрузки выполняется автоматически путем перераспределения получателей по разделам (partition) топика.| 
| Пропускная  | 20  тыс.с./с |89  тыс.с./с   также Kafka гарантирует порядок сообщений в разделе топика (partition) без конкурирующих получателей, что позволяет объединять сообщения в пакеты для более эффективной доставки и повышает пропускную способность системы.| 
| Масштабируемость| RabbitMQ меньшая масштабируемость, но большинство из нас не Google и не Facebook. Большинство из нас имеет дело с ежедневными объемами сообщений от сотен тысяч до сотен миллионов, а не с объемами от миллиардов до триллионов (но кстати, существуют кейсы, когда люди масштабировали RabbitMQ до миллиардов ежедневных сообщений). | Apache Kafka славится способностью поглощать и пересылать титанические объемы данных. В нем есть все, что нужно для работы с высокими нагрузками: репликация, горизонтальное масштабирование, параллельная обработка потоков сообщений сразу на нескольких серверах.| 
| Маршрутизация|  RabbitMQ включает 4 способа маршрутизации на разные обменники (exchange) для постановки в различные очереди, что позволяет использовать мощный и гибкий набор шаблонов обменов сообщениями. | Кафка реализует лишь 1 способ записи сообщений на диск, без маршрутизации. | 
| Упорядочивание сообщений| Кролик позволяет поддерживать относительный порядок в произвольных наборах (группах) событий| Кафка обеспечивает простой способ поддержания упорядочения с поддержкой масштабирования путем последовательной записи сообщений в реплицированный журнал (топик) | 
| Работа с клиентом|  про Apache Kafka говорят «тупой сервер, умный клиент», что означает необходимость реализации логики работы с сообщениями на клиентской стороне, т.е consumer заботится о получении нужных сообщений.| RabbitMQ – наоборот, «умный сервер, тупой клиент», поскольку этот брокер сам обеспечивает всю логику работы с сообщениями.|
 
Про пропускную способность смотрел здесь 

https://moluch.ru/archive/153/43351/


Про сравнения информацию брал из:

https://habr.com/ru/company/itsumma/blog/416629/
https://www.bigdataschool.ru/blog/kafka-vs-rabbitmq-big-data.html
https://zen.yandex.ru/media/mcs/rabbitmq-ili-apache-kafka-kakoi-broker-soobscenii-podoidet-dlia-vashego-proekta-601d6fab86f4e22208be5ff6

Выбирайте RabbitMQ , если вам нужна надежность и гибкость маршрутизации, а порядок доставки сообщений безразличен.

Apache Kafka подойдет, если работаете с большими нагрузками, вам важна масштабируемость, доставка сообщений в правильном порядке и возможность просматривать историю сообщений.

Ну и конечно же Kafka хайп, вторым вопросом у всех HR которые мне звонят на должность джуна - спрашивают умеешь ли в Кубер, а дальше сразу спрашивают работал ли с Kafka.

Пока не умею, но обязательно научусь ;)